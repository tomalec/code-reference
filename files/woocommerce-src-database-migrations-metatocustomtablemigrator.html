<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>WooCommerce Code Reference</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../images/favicon.png" />
    <link rel="apple-touch-icon" href="../images/apple-touch-icon.png"/>
    <link rel="apple-touch-icon" sizes="72x72" href="../images/apple-touch-icon-72x72.png"/>
    <link rel="apple-touch-icon" sizes="114x114" href="../images/apple-touch-icon-114x114.png"/>
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="../css/base.css?updated=1692866952">
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/template.css?updated=1692866952">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0/css/all.min.css" integrity="sha256-ybRkN9dBjhcS2qrW1z+hfCxq+1aBdwyQM5wlQoQVt/0=" crossorigin="anonymous" />
            <script src="https://cdn.jsdelivr.net/npm/css-vars-ponyfill@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0/js/all.min.js" integrity="sha256-0vuk8LXoyrmCjp1f0O300qo1M75ZQyhH9X3J6d+scmk=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tarekraafat/autocomplete.js@7.2.0/dist/js/autoComplete.min.js"></script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8KCYZ2CYMS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8KCYZ2CYMS', {
		'content_group' : 'WooCommerce Core Code Reference',
	});
</script>
        <script src="../js/prism.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            window.dispatchEvent(new HashChangeEvent('hashchange'));
        });
    </script>
</head>
<body id="top">
    <header class="phpdocumentor-top-header">
    <section class="phpdocumentor-section">
        <div class="site-branding">
            <a class="site-logo" href="../index.html"><img width="180" src="../images/logo.svg" alt="WooCommerce" /></a>
        </div>
        <nav class="main-navigation">
            <ul>
                <li><a href="../hooks/hooks.html">Hooks Reference</a></li>
                <li><a href="https://docs.woocommerce.com/">Documentation</a></li>
                <li><a href="https://woocommerce.github.io/woocommerce-rest-api-docs/">REST API Docs</a></li>
                <li><a href="https://woocommerce.com/careers/?utm_source=woocommerce+core+code+reference&utm_medium=devdocs&utm_campaign=woo+careers" target="_blank">We're hiring!</a></li>
            </ul>
        </nav>
    </section>
</header>

<div class="phpdocumentor-header">
    <section class="phpdocumentor-section">
        <h1 class="phpdocumentor-title">WooCommerce Code Reference</h1>
        <section class="phpdocumentor-search">
    <label class="phpdocumentor-label">
        <span class="visually-hidden">Search (click ESC to close search results)</span>
        <input id="autoComplete" tabindex="1" type="search" class="phpdocumentor-field phpdocumentor-search__field" placeholder="Loading..." disabled />
    </label>
</section>

    </section>
</div>

    <main class="phpdocumentor">
        <div class="phpdocumentor-section">
            <aside class="phpdocumentor-column -four phpdocumentor-sidebar">
    
    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Namespaces</h2>
                                <h3 class="phpdocumentor-sidebar__root-namespace"><a href="../namespaces/default.html"><abbr title="\">Global</abbr></a></h3>
                                        <h4 class="phpdocumentor-sidebar__root-namespace"><a href="../namespaces/woocommerce.html"><abbr title="\WooCommerce">WooCommerce</abbr></a></h4>
                <ul class="phpdocumentor-list">
                                            <li><a href="../namespaces/woocommerce-admin.html"><abbr title="\WooCommerce\Admin">Admin</abbr></a></li>
                                    </ul>
                            <h4 class="phpdocumentor-sidebar__root-namespace"><a href="../namespaces/automattic.html"><abbr title="\Automattic">Automattic</abbr></a></h4>
                <ul class="phpdocumentor-list">
                                            <li><a href="../namespaces/automattic-woocommerce.html"><abbr title="\Automattic\WooCommerce">WooCommerce</abbr></a></li>
                                    </ul>
                        </section>

        <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Packages</h2>
                    <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WooCommerce.html"><abbr title="\WooCommerce">WooCommerce</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="../packages/WooCommerce-Classes.html"><abbr title="\WooCommerce\Classes">Classes</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Abstracts.html"><abbr title="\WooCommerce\Abstracts">Abstracts</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Admin.html"><abbr title="\WooCommerce\Admin">Admin</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Helper.html"><abbr title="\WooCommerce\Helper">Helper</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Views.html"><abbr title="\WooCommerce\Views">Views</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Templates.html"><abbr title="\WooCommerce\Templates">Templates</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Reports.html"><abbr title="\WooCommerce\Reports">Reports</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Blocks.html"><abbr title="\WooCommerce\Blocks">Blocks</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-RestApi.html"><abbr title="\WooCommerce\RestApi">RestApi</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-CLI.html"><abbr title="\WooCommerce\CLI">CLI</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-l10n.html"><abbr title="\WooCommerce\l10n">l10n</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Webhooks.html"><abbr title="\WooCommerce\Webhooks">Webhooks</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-DataStores.html"><abbr title="\WooCommerce\DataStores">DataStores</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Emails.html"><abbr title="\WooCommerce\Emails">Emails</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Export.html"><abbr title="\WooCommerce\Export">Export</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Gateways.html"><abbr title="\WooCommerce\Gateways">Gateways</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-PayPal.html"><abbr title="\WooCommerce\PayPal">PayPal</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Import.html"><abbr title="\WooCommerce\Import">Import</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Integrations.html"><abbr title="\WooCommerce\Integrations">Integrations</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Interfaces.html"><abbr title="\WooCommerce\Interfaces">Interfaces</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Interface.html"><abbr title="\WooCommerce\Interface">Interface</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-LogHandlers.html"><abbr title="\WooCommerce\LogHandlers">LogHandlers</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-PaymentTokens.html"><abbr title="\WooCommerce\PaymentTokens">PaymentTokens</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Utilities.html"><abbr title="\WooCommerce\Utilities">Utilities</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Shipping.html"><abbr title="\WooCommerce\Shipping">Shipping</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Shortcodes.html"><abbr title="\WooCommerce\Shortcodes">Shortcodes</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Tracks.html"><abbr title="\WooCommerce\Tracks">Tracks</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Traits.html"><abbr title="\WooCommerce\Traits">Traits</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Functions.html"><abbr title="\WooCommerce\Functions">Functions</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-WCCom.html"><abbr title="\WooCommerce\WCCom">WCCom</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-WCCOM.html"><abbr title="\WooCommerce\WCCOM">WCCOM</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Widgets.html"><abbr title="\WooCommerce\Widgets">Widgets</abbr></a></li>
                                    <li><a href="../packages/WooCommerce-Uninstaller.html"><abbr title="\WooCommerce\Uninstaller">Uninstaller</abbr></a></li>
                            </ul>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WoocommerceAdmin.html"><abbr title="\WoocommerceAdmin">WoocommerceAdmin</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/WoocommerceNavigation.html"><abbr title="\WoocommerceNavigation">WoocommerceNavigation</abbr></a></h3>
                                <h3 class="phpdocumentor-sidebar__root-package"><a href="../packages/Automattic.html"><abbr title="\Automattic">Automattic</abbr></a></h3>
                        <ul class="phpdocumentor-list">
                                    <li><a href="../packages/Automattic-WooCommerce.html"><abbr title="\Automattic\WooCommerce">WooCommerce</abbr></a></li>
                            </ul>
                        </section>
    
    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Reports</h2>
                <h3 class="phpdocumentor-sidebar__root-package"><a href="../reports/deprecated.html">Deprecated</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="../reports/errors.html">Errors</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="../reports/markers.html">Markers</a></h3>
    </section>

    <section class="phpdocumentor-sidebar__category">
        <h2 class="phpdocumentor-sidebar__category-header">Indices</h2>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="../indices/files.html">Files</a></h3>
        <h3 class="phpdocumentor-sidebar__root-package"><a href="../hooks/hooks.html">Hooks Reference</a></h3>
    </section>
</aside>

            <div class="phpdocumentor-column -eight phpdocumentor-content">
                    <ul class="phpdocumentor-breadcrumbs">
    </ul>

    <article class="phpdocumentor-element -file">
        <h2 class="phpdocumentor-content__title">MetaToCustomTableMigrator.php</h2>

                

        
                    <h3 class="phpdocumentor-elements__header" id="source-code">
                Source code
                <a href="#source-code" class="headerlink"><i class="fas fa-link"></i></a>
            </h3>
            <pre id="source-view" tabindex="-1" class="language-php line-numbers linkable-line-numbers"><code>&lt;?php
/**
 * Generic migration class to move any entity, entity_meta table combination to custom table.
 */

namespace Automattic\WooCommerce\Database\Migrations;

/**
 * Base class for implementing migrations from the standard WordPress meta table
 * to custom structured tables.
 *
 * @package Automattic\WooCommerce\Database\Migrations\CustomOrderTable
 */
abstract class MetaToCustomTableMigrator extends TableMigrator {

	/**
	 * Config for tables being migrated and migrated from. See __construct() for detailed config.
	 *
	 * @var array
	 */
	protected $schema_config;

	/**
	 * Meta config, see __construct for detailed config.
	 *
	 * @var array
	 */
	protected $meta_column_mapping;

	/**
	 * Column mapping from source table to destination custom table. See __construct for detailed config.
	 *
	 * @var array
	 */
	protected $core_column_mapping;

	/**
	 * MetaToCustomTableMigrator constructor.
	 */
	public function __construct() {
		$this-&gt;schema_config       = MigrationHelper::escape_schema_for_backtick( $this-&gt;get_schema_config() );
		$this-&gt;meta_column_mapping = $this-&gt;get_meta_column_config();
		$this-&gt;core_column_mapping = $this-&gt;get_core_column_mapping();
	}

	/**
	 * Specify schema config the source and destination table.
	 *
	 * @return array Schema, must of the form:
	 * array(
		&#039;source&#039; =&gt; array(
			&#039;entity&#039; =&gt; array(
				&#039;table_name&#039; =&gt; $source_table_name,
				&#039;meta_rel_column&#039; =&gt; $column_meta, Name of column in source table which is referenced by meta table.
				&#039;destination_rel_column&#039; =&gt; $column_dest, Name of column in source table which is refenced by destination table,
				&#039;primary_key&#039; =&gt; $primary_key, Primary key of the source table
			),
			&#039;meta&#039; =&gt; array(
				&#039;table&#039; =&gt; $meta_table_name,
				&#039;meta_key_column&#039; =&gt; $meta_key_column_name,
				&#039;meta_value_column&#039; =&gt; $meta_value_column_name,
				&#039;entity_id_column&#039; =&gt; $entity_id_column, Name of the column having entity IDs.
			),
		),
		&#039;destination&#039; =&gt; array(
			&#039;table_name&#039; =&gt; $table_name, Name of destination table,
			&#039;source_rel_column&#039; =&gt; $column_source_id, Name of the column in destination table which is referenced by source table.
			&#039;primary_key&#039; =&gt; $table_primary_key,
			&#039;primary_key_type&#039; =&gt; $type bool|int|string|decimal
		)
	 */
	abstract protected function get_schema_config(): array;

	/**
	 * Specify column config from the source table.
	 *
	 * @return array Config, must be of the form:
	 * array(
	 *  &#039;$source_column_name_1&#039; =&gt; array( // $source_column_name_1 is column name in source table, or a select statement.
	 *      &#039;type&#039; =&gt; &#039;type of value, could be string/int/date/float.&#039;,
	 *      &#039;destination&#039; =&gt; &#039;name of the column in column name where this data should be inserted in.&#039;,
	 *  ),
	 *  &#039;$source_column_name_2&#039; =&gt; array(
	 *          ......
	 *  ),
	 *  ....
	 * ).
	 */
	abstract protected function get_core_column_mapping(): array;

	/**
	 * Specify meta keys config from source meta table.
	 *
	 * @return array Config, must be of the form.
	 * array(
	 *  &#039;$meta_key_1&#039; =&gt; array(  // $meta_key_1 is the name of meta_key in source meta table.
	 *          &#039;type&#039; =&gt; &#039;type of value, could be string/int/date/float&#039;,
	 *          &#039;destination&#039; =&gt; &#039;name of the column in column name where this data should be inserted in.&#039;,
	 *  ),
	 *  &#039;$meta_key_2&#039; =&gt; array(
	 *          ......
	 *  ),
	 *  ....
	 * ).
	 */
	abstract protected function get_meta_column_config(): array;

	/**
	 * Generate SQL for data insertion.
	 *
	 * @param array $batch Data to generate queries for. Will be &#039;data&#039; array returned by `$this-&gt;fetch_data_for_migration_for_ids()` method.
	 *
	 * @return string Generated queries for insertion for this batch, would be of the form:
	 * INSERT IGNORE INTO $table_name ($columns) values
	 *  ($value for row 1)
	 *  ($value for row 2)
	 * ...
	 */
	private function generate_insert_sql_for_batch( array $batch ): string {
		$table = $this-&gt;schema_config[&#039;destination&#039;][&#039;table_name&#039;];

		list( $value_sql, $column_sql ) = $this-&gt;generate_column_clauses( array_merge( $this-&gt;core_column_mapping, $this-&gt;meta_column_mapping ), $batch );

		return &quot;INSERT INTO $table (`$column_sql`) VALUES $value_sql;&quot;; // phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared, -- $insert_query is hardcoded, $value_sql is already escaped.
	}

	/**
	 * Generate SQL for data updating.
	 *
	 * @param array $batch Data to generate queries for. Will be `data` array returned by fetch_data_for_migration_for_ids() method.
	 *
	 * @param array $entity_row_mapping Maps rows to update data with their original IDs. Will be returned by `generate_update_sql_for_batch`.
	 *
	 * @return string Generated queries for batch update. Would be of the form:
	 * INSERT INTO $table ( $columns ) VALUES
	 *  ($value for row 1)
	 *  ($valye for row 2)
	 * ...
	 * ON DUPLICATE KEY UPDATE
	 * $column1 = VALUES($column1)
	 * $column2 = VALUES($column2)
	 * ...
	 */
	private function generate_update_sql_for_batch( array $batch, array $entity_row_mapping ): string {
		$table = $this-&gt;schema_config[&#039;destination&#039;][&#039;table_name&#039;];

		$destination_primary_id_schema = $this-&gt;get_destination_table_primary_id_schema();
		foreach ( $batch as $entity_id =&gt; $row ) {
			$batch[ $entity_id ][ $destination_primary_id_schema[&#039;destination_primary_key&#039;][&#039;destination&#039;] ] = $entity_row_mapping[ $entity_id ]-&gt;destination_id;
		}

		list( $value_sql, $column_sql, $columns ) = $this-&gt;generate_column_clauses(
			array_merge( $destination_primary_id_schema, $this-&gt;core_column_mapping, $this-&gt;meta_column_mapping ),
			$batch
		);

		$duplicate_update_key_statement = MigrationHelper::generate_on_duplicate_statement_clause( $columns );

		return &quot;INSERT INTO $table (`$column_sql`) VALUES $value_sql $duplicate_update_key_statement;&quot;;
	}

	/**
	 * Generate schema for primary ID column of destination table.
	 *
	 * @return array[] Schema for primary ID column.
	 */
	private function get_destination_table_primary_id_schema(): array {
		return array(
			&#039;destination_primary_key&#039; =&gt; array(
				&#039;destination&#039; =&gt; $this-&gt;schema_config[&#039;destination&#039;][&#039;primary_key&#039;],
				&#039;type&#039;        =&gt; $this-&gt;schema_config[&#039;destination&#039;][&#039;primary_key_type&#039;],
			),
		);
	}

	/**
	 * Generate values and columns clauses to be used in INSERT and INSERT..ON DUPLICATE KEY UPDATE statements.
	 *
	 * @param array $columns_schema Columns config for destination table.
	 * @param array $batch Actual data to migrate as returned by `data` in `fetch_data_for_migration_for_ids` method.
	 *
	 * @return array SQL clause for values, columns placeholders, and columns.
	 */
	private function generate_column_clauses( array $columns_schema, array $batch ): array {
		global $wpdb;

		$columns      = array();
		$placeholders = array();
		foreach ( $columns_schema as $prev_column =&gt; $schema ) {
			if ( in_array( $schema[&#039;destination&#039;], $columns, true ) ) {
				continue;
			}
			$columns[]      = $schema[&#039;destination&#039;];
			$placeholders[] = MigrationHelper::get_wpdb_placeholder_for_type( $schema[&#039;type&#039;] );
		}

		$values = array();
		foreach ( array_values( $batch ) as $row ) {
			$row_values = array();
			foreach ( $columns as $index =&gt; $column ) {
				if ( ! isset( $row[ $column ] ) || is_null( $row[ $column ] ) ) {
					$row_values[] = &#039;NULL&#039;;
				} else {
					// phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared, WordPress.DB.PreparedSQL.NotPrepared -- $placeholders is a placeholder.
					$row_values[] = $wpdb-&gt;prepare( $placeholders[ $index ], $row[ $column ] );
				}
			}

			$value_string = &#039;(&#039; . implode( &#039;,&#039;, $row_values ) . &#039;)&#039;;
			$values[]     = $value_string;
		}

		$value_sql = implode( &#039;,&#039;, $values );

		$column_sql = implode( &#039;`, `&#039;, $columns );

		return array( $value_sql, $column_sql, $columns );
	}

	/**
	 * Return data to be migrated for a batch of entities.
	 *
	 * @param array $entity_ids Ids of entities to migrate.
	 *
	 * @return array[] Data to be migrated. Would be of the form: array( &#039;data&#039; =&gt; array( ... ), &#039;errors&#039; =&gt; array( ... ) ).
	 */
	public function fetch_sanitized_migration_data( $entity_ids ) {
		$this-&gt;clear_errors();
		$data = $this-&gt;fetch_data_for_migration_for_ids( $entity_ids );

		foreach ( $data[&#039;errors&#039;] as $entity_id =&gt; $errors ) {
			foreach ( $errors as $column_name =&gt; $error_message ) {
				$this-&gt;add_error( &quot;Error importing data for post with id $entity_id: column $column_name: $error_message&quot; );
			}
		}
		return array(
			&#039;data&#039;   =&gt; $data[&#039;data&#039;],
			&#039;errors&#039; =&gt; $this-&gt;get_errors(),
		);
	}

	/**
	 * Migrate a batch of entities from the posts table to the corresponding table.
	 *
	 * @param array $entity_ids Ids of entities to migrate.
	 *
	 * @return void
	 */
	protected function process_migration_batch_for_ids_core( array $entity_ids ): void {
		$data = $this-&gt;fetch_sanitized_migration_data( $entity_ids );
		$this-&gt;process_migration_data( $data );
	}

	/**
	 * Process migration data for a batch of entities.
	 *
	 * @param array $data Data to be migrated. Should be of the form: array( &#039;data&#039; =&gt; array( ... ) ) as returned by the `fetch_sanitized_migration_data` method.
	 *
	 * @return array Array of errors and exception if any.
	 */
	public function process_migration_data( array $data ) {
		$this-&gt;clear_errors();
		$exception = null;

		if ( count( $data[&#039;data&#039;] ) === 0 ) {
			return array(
				&#039;errors&#039;    =&gt; $this-&gt;get_errors(),
				&#039;exception&#039; =&gt; null,
			);
		}

		try {
			$entity_ids       = array_keys( $data[&#039;data&#039;] );
			$existing_records = $this-&gt;get_already_existing_records( $entity_ids );

			$to_insert = array_diff_key( $data[&#039;data&#039;], $existing_records );
			$this-&gt;process_insert_batch( $to_insert );

			$to_update = array_intersect_key( $data[&#039;data&#039;], $existing_records );
			$this-&gt;process_update_batch( $to_update, $existing_records );
		} catch ( \Exception $e ) {
			$exception = $e;
		}

		return array(
			&#039;errors&#039;    =&gt; $this-&gt;get_errors(),
			&#039;exception&#039; =&gt; $exception,
		);
	}

	/**
	 * Process batch for insertion into destination table.
	 *
	 * @param array $batch Data to insert, will be of the form as returned by `data` in `fetch_data_for_migration_for_ids`.
	 */
	private function process_insert_batch( array $batch ): void {
		if ( 0 === count( $batch ) ) {
			return;
		}

		$queries = $this-&gt;generate_insert_sql_for_batch( $batch );
		// phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared -- Queries should already be prepared.
		$processed_rows_count = $this-&gt;db_query( $queries );
		$this-&gt;maybe_add_insert_or_update_error( &#039;insert&#039;, $processed_rows_count );
	}

	/**
	 * Process batch for update into destination table.
	 *
	 * @param array $batch Data to insert, will be of the form as returned by `data` in `fetch_data_for_migration_for_ids`.
	 * @param array $ids_mapping Maps rows to update data with their original IDs.
	 */
	private function process_update_batch( array $batch, array $ids_mapping ): void {
		if ( 0 === count( $batch ) ) {
			return;
		}

		$queries = $this-&gt;generate_update_sql_for_batch( $batch, $ids_mapping );
		// phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared -- Queries should already be prepared.
		$processed_rows_count = $this-&gt;db_query( $queries ) / 2;
		$this-&gt;maybe_add_insert_or_update_error( &#039;update&#039;, $processed_rows_count );
	}


	/**
	 * Fetch data for migration.
	 *
	 * @param array $entity_ids Entity IDs to fetch data for.
	 *
	 * @return array[] Data along with errors (if any), will of the form:
	 * array(
	 *  &#039;data&#039; =&gt; array(
	 *      &#039;id_1&#039; =&gt; array( &#039;column1&#039; =&gt; value1, &#039;column2&#039; =&gt; value2, ...),
	 *      ...,
	 *   ),
	 *  &#039;errors&#039; =&gt; array(
	 *      &#039;id_1&#039; =&gt; array( &#039;column1&#039; =&gt; error1, &#039;column2&#039; =&gt; value2, ...),
	 *      ...,
	 * )
	 */
	private function fetch_data_for_migration_for_ids( array $entity_ids ): array {
		if ( empty( $entity_ids ) ) {
			return array(
				&#039;data&#039;   =&gt; array(),
				&#039;errors&#039; =&gt; array(),
			);
		}

		$entity_table_query = $this-&gt;build_entity_table_query( $entity_ids );
		// phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared -- Output of $this-&gt;build_entity_table_query is already prepared.
		$entity_data = $this-&gt;db_get_results( $entity_table_query );
		if ( empty( $entity_data ) ) {
			return array(
				&#039;data&#039;   =&gt; array(),
				&#039;errors&#039; =&gt; array(),
			);
		}
		$entity_meta_rel_ids = array_column( $entity_data, &#039;entity_meta_rel_id&#039; );

		$meta_table_query = $this-&gt;build_meta_data_query( $entity_meta_rel_ids );
		// phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared -- Output of $this-&gt;build_meta_data_query is already prepared.
		$meta_data = $this-&gt;db_get_results( $meta_table_query );

		return $this-&gt;process_and_sanitize_data( $entity_data, $meta_data );
	}

	/**
	 * Fetch id mappings for records that are already inserted in the destination table.
	 *
	 * @param array $entity_ids List of entity IDs to verify.
	 *
	 * @return array Already migrated entities, would be of the form
	 * array(
	 *      &#039;$source_id1&#039; =&gt; array(
	 *          &#039;source_id&#039; =&gt; $source_id1,
	 *          &#039;destination_id&#039; =&gt; $destination_id1
	 *          &#039;modified&#039; =&gt; 0 if it can be determined that the row doesn&#039;t need update, 1 otherwise
	 *      ),
	 *      ...
	 * )
	 */
	protected function get_already_existing_records( array $entity_ids ): array {
		global $wpdb;

		$source_table                   = $this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;table_name&#039;];
		$source_destination_join_column = $this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;destination_rel_column&#039;];
		$source_primary_key_column      = $this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;primary_key&#039;];

		$destination_table              = $this-&gt;schema_config[&#039;destination&#039;][&#039;table_name&#039;];
		$destination_source_join_column = $this-&gt;schema_config[&#039;destination&#039;][&#039;source_rel_column&#039;];
		$destination_primary_key_column = $this-&gt;schema_config[&#039;destination&#039;][&#039;primary_key&#039;];

		$entity_id_placeholder = implode( &#039;,&#039;, array_fill( 0, count( $entity_ids ), &#039;%d&#039; ) );

		$additional_where = $this-&gt;get_additional_where_clause_for_get_data_to_insert_or_update( $entity_ids );

		$already_migrated_entity_ids = $this-&gt;db_get_results(
			$wpdb-&gt;prepare(
			// phpcs:disable WordPress.DB.PreparedSQL.InterpolatedNotPrepared, WordPress.DB.PreparedSQLPlaceholders.UnfinishedPrepare -- All columns and table names are hardcoded.
				&quot;
SELECT source.`$source_primary_key_column` as source_id, destination.`$destination_primary_key_column` as destination_id
FROM `$destination_table` destination
JOIN `$source_table` source ON source.`$source_destination_join_column` = destination.`$destination_source_join_column`
WHERE source.`$source_primary_key_column` IN ( $entity_id_placeholder ) $additional_where
&quot;,
				$entity_ids
			)
		// phpcs:enable
		);

		return array_column( $already_migrated_entity_ids, null, &#039;source_id&#039; );
	}

	/**
	 * Get additional string to be appended to the WHERE clause of the SQL query used by get_data_to_insert_or_update.
	 *
	 * @param array $entity_ids The ids of the entities being inserted or updated.
	 * @return string Additional string for the WHERE clause, must either be empty or start with &quot;AND&quot; or &quot;OR&quot;.
	 */
	protected function get_additional_where_clause_for_get_data_to_insert_or_update( array $entity_ids ): string {
		return &#039;&#039;;
	}

	/**
	 * Helper method to build query used to fetch data from core source table.
	 *
	 * @param array $entity_ids List of entity IDs to fetch.
	 *
	 * @return string Query that can be used to fetch data.
	 */
	private function build_entity_table_query( array $entity_ids ): string {
		global $wpdb;

		$source_entity_table       = $this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;table_name&#039;];
		$source_meta_rel_id_column = &quot;`$source_entity_table`.`{$this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;meta_rel_column&#039;]}`&quot;;
		$source_primary_key_column = &quot;`$source_entity_table`.`{$this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;primary_key&#039;]}`&quot;;

		$where_clause = &quot;$source_primary_key_column IN (&quot; . implode( &#039;,&#039;, array_fill( 0, count( $entity_ids ), &#039;%d&#039; ) ) . &#039;)&#039;;
		$entity_keys  = array();
		foreach ( $this-&gt;core_column_mapping as $column_name =&gt; $column_schema ) {
			if ( isset( $column_schema[&#039;select_clause&#039;] ) ) {
				$select_clause = $column_schema[&#039;select_clause&#039;];
				$entity_keys[] = &quot;$select_clause AS $column_name&quot;;
			} else {
				$entity_keys[] = &quot;$source_entity_table.$column_name&quot;;
			}
		}
		$entity_column_string = implode( &#039;, &#039;, $entity_keys );
		// phpcs:disable WordPress.DB.PreparedSQL.InterpolatedNotPrepared, WordPress.DB.PreparedSQLPlaceholders.UnfinishedPrepare -- $source_meta_rel_id_column, $source_destination_rel_id_column etc is escaped for backticks. $where clause and $order_by should already be escaped.
		$query = $wpdb-&gt;prepare(
			&quot;
SELECT
	$source_meta_rel_id_column as entity_meta_rel_id,
    $source_primary_key_column as primary_key_id,
	$entity_column_string
FROM `$source_entity_table`
WHERE $where_clause;
&quot;,
			$entity_ids
		);

		// phpcs:enable

		return $query;
	}

	/**
	 * Helper method to build query that will be used to fetch data from source meta table.
	 *
	 * @param array $entity_ids List of IDs to fetch metadata for.
	 *
	 * @return string Query for fetching meta data.
	 */
	private function build_meta_data_query( array $entity_ids ): string {
		global $wpdb;

		$meta_table                = $this-&gt;schema_config[&#039;source&#039;][&#039;meta&#039;][&#039;table_name&#039;];
		$meta_keys                 = array_keys( $this-&gt;meta_column_mapping );
		$meta_key_column           = $this-&gt;schema_config[&#039;source&#039;][&#039;meta&#039;][&#039;meta_key_column&#039;];
		$meta_value_column         = $this-&gt;schema_config[&#039;source&#039;][&#039;meta&#039;][&#039;meta_value_column&#039;];
		$meta_table_relational_key = $this-&gt;schema_config[&#039;source&#039;][&#039;meta&#039;][&#039;entity_id_column&#039;];

		$meta_column_string = implode( &#039;, &#039;, array_fill( 0, count( $meta_keys ), &#039;%s&#039; ) );
		$entity_id_string   = implode( &#039;, &#039;, array_fill( 0, count( $entity_ids ), &#039;%d&#039; ) );

		// phpcs:disable WordPress.DB.PreparedSQL.InterpolatedNotPrepared, WordPress.DB.PreparedSQLPlaceholders.UnfinishedPrepare -- $meta_table_relational_key, $meta_key_column, $meta_value_column and $meta_table is escaped for backticks. $entity_id_string and $meta_column_string are placeholders.
		$query = $wpdb-&gt;prepare(
			&quot;
SELECT `$meta_table_relational_key` as entity_id, `$meta_key_column` as meta_key, `$meta_value_column` as meta_value
FROM `$meta_table`
WHERE
	`$meta_table_relational_key` IN ( $entity_id_string )
	AND `$meta_key_column` IN ( $meta_column_string );
&quot;,
			array_merge(
				$entity_ids,
				$meta_keys
			)
		);

		// phpcs:enable

		return $query;
	}

	/**
	 * Helper function to validate and combine data before we try to insert.
	 *
	 * @param array $entity_data Data from source table.
	 * @param array $meta_data Data from meta table.
	 *
	 * @return array[] Validated and combined data with errors.
	 */
	private function process_and_sanitize_data( array $entity_data, array $meta_data ): array {
		$sanitized_entity_data = array();
		$error_records         = array();
		$this-&gt;process_and_sanitize_entity_data( $sanitized_entity_data, $error_records, $entity_data );
		$this-&gt;processs_and_sanitize_meta_data( $sanitized_entity_data, $error_records, $meta_data );

		return array(
			&#039;data&#039;   =&gt; $sanitized_entity_data,
			&#039;errors&#039; =&gt; $error_records,
		);
	}

	/**
	 * Helper method to sanitize core source table.
	 *
	 * @param array $sanitized_entity_data Array containing sanitized data for insertion.
	 * @param array $error_records Error records.
	 * @param array $entity_data Original source data.
	 */
	private function process_and_sanitize_entity_data( array &amp;$sanitized_entity_data, array &amp;$error_records, array $entity_data ): void {
		foreach ( $entity_data as $entity ) {
			$row_data = array();
			foreach ( $this-&gt;core_column_mapping as $column_name =&gt; $schema ) {
				$custom_table_column_name = $schema[&#039;destination&#039;] ?? $column_name;
				$value                    = $entity-&gt;$column_name;
				$value                    = $this-&gt;validate_data( $value, $schema[&#039;type&#039;] );
				if ( is_wp_error( $value ) ) {
					$error_records[ $entity-&gt;primary_key_id ][ $custom_table_column_name ] = $value-&gt;get_error_code();
				} else {
					$row_data[ $custom_table_column_name ] = $value;
				}
			}
			$sanitized_entity_data[ $entity-&gt;entity_meta_rel_id ] = $row_data;
		}
	}

	/**
	 * Helper method to sanitize soure meta data.
	 *
	 * @param array $sanitized_entity_data Array containing sanitized data for insertion.
	 * @param array $error_records Error records.
	 * @param array $meta_data Original source data.
	 */
	private function processs_and_sanitize_meta_data( array &amp;$sanitized_entity_data, array &amp;$error_records, array $meta_data ): void {
		foreach ( $meta_data as $datum ) {
			$column_schema = $this-&gt;meta_column_mapping[ $datum-&gt;meta_key ];
			if ( isset( $sanitized_entity_data[ $datum-&gt;entity_id ][ $column_schema[&#039;destination&#039;] ] ) ) {
				// We pick only the first meta if there are duplicates for a flat column, to be consistent with WP core behavior in handing duplicate meta which are marked as unique.
				continue;
			}
			$value = $this-&gt;validate_data( $datum-&gt;meta_value, $column_schema[&#039;type&#039;] );
			if ( is_wp_error( $value ) ) {
				$error_records[ $datum-&gt;entity_id ][ $column_schema[&#039;destination&#039;] ] = &quot;{$value-&gt;get_error_code()}: {$value-&gt;get_error_message()}&quot;;
			} else {
				$sanitized_entity_data[ $datum-&gt;entity_id ][ $column_schema[&#039;destination&#039;] ] = $value;
			}
		}
	}

	/**
	 * Validate and transform data so that we catch as many errors as possible before inserting.
	 *
	 * @param mixed  $value Actual data value.
	 * @param string $type Type of data, could be decimal, int, date, string.
	 *
	 * @return float|int|mixed|string|\WP_Error
	 */
	private function validate_data( $value, string $type ) {
		switch ( $type ) {
			case &#039;decimal&#039;:
				$value = wc_format_decimal( floatval( $value ), false, true );
				break;
			case &#039;int&#039;:
				$value = (int) $value;
				break;
			case &#039;bool&#039;:
				$value = wc_string_to_bool( $value );
				break;
			case &#039;date&#039;:
				try {
					if ( &#039;&#039; === $value ) {
						$value = null;
					} else {
						$value = ( new \DateTime( $value ) )-&gt;format( &#039;Y-m-d H:i:s&#039; );
					}
				} catch ( \Exception $e ) {
					return new \WP_Error( $e-&gt;getMessage() );
				}
				break;
			case &#039;date_epoch&#039;:
				try {
					if ( &#039;&#039; === $value ) {
						$value = null;
					} else {
						$value = ( new \DateTime( &quot;@$value&quot; ) )-&gt;format( &#039;Y-m-d H:i:s&#039; );
					}
				} catch ( \Exception $e ) {
					return new \WP_Error( $e-&gt;getMessage() );
				}
				break;
		}

		return $value;
	}

	/**
	 * Verify whether data was migrated properly for given IDs.
	 *
	 * @param array $source_ids List of source IDs.
	 *
	 * @return array List of IDs along with columns that failed to migrate.
	 */
	public function verify_migrated_data( array $source_ids ) : array {
		global $wpdb;
		$query = $this-&gt;build_verification_query( $source_ids );
		// phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared -- $query should already be prepared.
		$results = $wpdb-&gt;get_results( $query, ARRAY_A );
		$results = $this-&gt;fill_source_metadata( $results, $source_ids );
		return $this-&gt;verify_data( $results );
	}

	/**
	 * Generate query to fetch data from both source and destination tables. Use the results in `verify_data` to verify if data was migrated properly.
	 *
	 * @param array $source_ids Array of IDs in source table.
	 *
	 * @return string SELECT statement.
	 */
	protected function build_verification_query( $source_ids ) {
		$source_table                  = $this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;table_name&#039;];
		$destination_table             = $this-&gt;schema_config[&#039;destination&#039;][&#039;table_name&#039;];
		$destination_source_rel_column = $this-&gt;schema_config[&#039;destination&#039;][&#039;source_rel_column&#039;];
		$source_destination_rel_column = $this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;destination_rel_column&#039;];

		$source_destination_join_clause = &quot;$destination_table ON $destination_table.$destination_source_rel_column = $source_table.$source_destination_rel_column&quot;;

		$meta_select_clauses        = array();
		$source_select_clauses      = array();
		$destination_select_clauses = array();

		foreach ( $this-&gt;core_column_mapping as $column_name =&gt; $schema ) {
			$source_select_column         = isset( $schema[&#039;select_clause&#039;] ) ? $schema[&#039;select_clause&#039;] : &quot;$source_table.$column_name&quot;;
			$source_select_clauses[]      = &quot;$source_select_column as {$source_table}_{$column_name}&quot;;
			$destination_select_clauses[] = &quot;$destination_table.{$schema[&#039;destination&#039;]} as {$destination_table}_{$schema[&#039;destination&#039;]}&quot;;
		}

		foreach ( $this-&gt;meta_column_mapping as $meta_key =&gt; $schema ) {
			$destination_select_clauses[] = &quot;$destination_table.{$schema[&#039;destination&#039;]} as {$destination_table}_{$schema[&#039;destination&#039;]}&quot;;
		}

		$select_clause = implode( &#039;, &#039;, array_merge( $source_select_clauses, $meta_select_clauses, $destination_select_clauses ) );

		$where_clause = $this-&gt;get_where_clause_for_verification( $source_ids );

		return &quot;
SELECT $select_clause
FROM $source_table
    LEFT JOIN $source_destination_join_clause
WHERE $where_clause
&quot;;
	}

	/**
	 * Fill source metadata for given IDs for verification. This will return filled data in following format:
	 * [
	 *    {
	 *      $source_table_$source_column: $value,
	 *      ...,
	 *      $destination_table_$destination_column: $value,
	 *      ...
	 *      meta_source_{$destination_column_name1}: $meta_value,
	 *      ...
	 *    },
	 *   ...
	 * ]
	 *
	 * @param array $results    Entity data from both source and destination table.
	 * @param array $source_ids List of source IDs.
	 *
	 * @return array Filled $results param with source metadata.
	 */
	private function fill_source_metadata( $results, $source_ids ) {
		global $wpdb;
		$meta_table            = $this-&gt;schema_config[&#039;source&#039;][&#039;meta&#039;][&#039;table_name&#039;];
		$meta_entity_id_column = $this-&gt;schema_config[&#039;source&#039;][&#039;meta&#039;][&#039;entity_id_column&#039;];
		$meta_key_column       = $this-&gt;schema_config[&#039;source&#039;][&#039;meta&#039;][&#039;meta_key_column&#039;];
		$meta_value_column     = $this-&gt;schema_config[&#039;source&#039;][&#039;meta&#039;][&#039;meta_value_column&#039;];
		$meta_id_column        = $this-&gt;schema_config[&#039;source&#039;][&#039;meta&#039;][&#039;meta_id_column&#039;];
		$meta_columns          = array_keys( $this-&gt;meta_column_mapping );

		$meta_columns_placeholder = implode( &#039;, &#039;, array_fill( 0, count( $meta_columns ), &#039;%s&#039; ) );
		$source_ids_placeholder   = implode( &#039;, &#039;, array_fill( 0, count( $source_ids ), &#039;%d&#039; ) );

		$query = $wpdb-&gt;prepare(
		// phpcs:disable WordPress.DB.PreparedSQL.InterpolatedNotPrepared, WordPress.DB.PreparedSQLPlaceholders.UnfinishedPrepare
			&quot;SELECT $meta_entity_id_column as entity_id, $meta_key_column as meta_key, $meta_value_column as meta_value
			FROM $meta_table
			WHERE $meta_entity_id_column IN ($source_ids_placeholder)
			AND $meta_key_column IN ($meta_columns_placeholder)
			ORDER BY $meta_id_column ASC&quot;,
			array_merge( $source_ids, $meta_columns )
		);
		//phpcs:enable

		// phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared
		$meta_data            = $wpdb-&gt;get_results( $query, ARRAY_A );
		$source_metadata_rows = array();
		foreach ( $meta_data as $meta_datum ) {
			if ( ! isset( $source_metadata_rows[ $meta_datum[&#039;entity_id&#039;] ] ) ) {
				$source_metadata_rows[ $meta_datum[&#039;entity_id&#039;] ] = array();
			}
			$destination_column = $this-&gt;meta_column_mapping[ $meta_datum[&#039;meta_key&#039;] ][&#039;destination&#039;];
			$alias              = &quot;meta_source_{$destination_column}&quot;;
			if ( isset( $source_metadata_rows[ $meta_datum[&#039;entity_id&#039;] ][ $alias ] ) ) {
				// Only process first value, duplicate values mapping to flat columns are ignored to be consistent with WP core.
				continue;
			}
			$source_metadata_rows[ $meta_datum[&#039;entity_id&#039;] ][ $alias ] = $meta_datum[&#039;meta_value&#039;];
		}
		foreach ( $results as $index =&gt; $result_row ) {
			$source_id         = $result_row[ $this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;table_name&#039;] . &#039;_&#039; . $this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;primary_key&#039;] ];
			$results[ $index ] = array_merge( $result_row, ( $source_metadata_rows[ $source_id ] ?? array() ) );
		}
		return $results;
	}

	/**
	 * Helper function to generate where clause for fetching data for verification.
	 *
	 * @param array $source_ids Array of IDs from source table.
	 *
	 * @return string WHERE clause.
	 */
	protected function get_where_clause_for_verification( $source_ids ) {
		global $wpdb;
		$source_primary_id_column = $this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;primary_key&#039;];
		$source_table             = $this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;table_name&#039;];
		$source_ids_placeholder   = implode( &#039;, &#039;, array_fill( 0, count( $source_ids ), &#039;%d&#039; ) );

		return $wpdb-&gt;prepare(
			// phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared, WordPress.DB.PreparedSQLPlaceholders.UnfinishedPrepare
			&quot;$source_table.$source_primary_id_column IN ($source_ids_placeholder)&quot;,
			$source_ids
		);
	}

	/**
	 * Verify data from both source and destination tables and check if they were migrated properly.
	 *
	 * @param array $collected_data Collected data in array format, should be in same structure as returned from query in `$this-&gt;build_verification_query`.
	 *
	 * @return array Array of failed IDs if any, along with columns/meta_key names.
	 */
	protected function verify_data( $collected_data ) {
		$failed_ids = array();
		foreach ( $collected_data as $row ) {
			$failed_ids = $this-&gt;verify_entity_columns( $row, $failed_ids );
			$failed_ids = $this-&gt;verify_meta_columns( $row, $failed_ids );
		}

		return $failed_ids;
	}

	/**
	 * Helper method to verify and compare core columns.
	 *
	 * @param array $row        Both migrated and source data for a single row.
	 * @param array $failed_ids Array of failed IDs.
	 *
	 * @return array Array of failed IDs if any, along with columns/meta_key names.
	 */
	private function verify_entity_columns( $row, $failed_ids ) {
		$primary_key_column = &quot;{$this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;table_name&#039;]}_{$this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;primary_key&#039;]}&quot;;
		foreach ( $this-&gt;core_column_mapping as $column_name =&gt; $schema ) {
			$source_alias      = &quot;{$this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;table_name&#039;]}_$column_name&quot;;
			$destination_alias = &quot;{$this-&gt;schema_config[&#039;destination&#039;][&#039;table_name&#039;]}_{$schema[&#039;destination&#039;]}&quot;;
			$row               = $this-&gt;pre_process_row( $row, $schema, $source_alias, $destination_alias );
			if ( $row[ $source_alias ] !== $row[ $destination_alias ] ) {
				if ( ! isset( $failed_ids[ $row[ $primary_key_column ] ] ) ) {
					$failed_ids[ $row[ $primary_key_column ] ] = array();
				}
				$failed_ids[ $row[ $primary_key_column ] ][] = array(
					&#039;column&#039;         =&gt; $column_name,
					&#039;original_value&#039; =&gt; $row[ $source_alias ],
					&#039;new_value&#039;      =&gt; $row[ $destination_alias ],
				);
			}
		}

		return $failed_ids;
	}

	/**
	 * Helper method to verify meta columns.
	 *
	 * @param array $row        Both migrated and source data for a single row.
	 * @param array $failed_ids Array of failed IDs.
	 *
	 * @return array Array of failed IDs if any, along with columns/meta_key names.
	 */
	private function verify_meta_columns( $row, $failed_ids ) {
		$primary_key_column = &quot;{$this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;table_name&#039;]}_{$this-&gt;schema_config[&#039;source&#039;][&#039;entity&#039;][&#039;primary_key&#039;]}&quot;;
		foreach ( $this-&gt;meta_column_mapping as $meta_key =&gt; $schema ) {
			$meta_alias        = &quot;meta_source_{$schema[&#039;destination&#039;]}&quot;;
			$destination_alias = &quot;{$this-&gt;schema_config[&#039;destination&#039;][&#039;table_name&#039;]}_{$schema[&#039;destination&#039;]}&quot;;
			$row               = $this-&gt;pre_process_row( $row, $schema, $meta_alias, $destination_alias );
			if ( $row[ $meta_alias ] !== $row[ $destination_alias ] ) {
				if ( ! isset( $failed_ids[ $row[ $primary_key_column ] ] ) ) {
					$failed_ids[ $row[ $primary_key_column ] ] = array();
				}
				$failed_ids[ $row[ $primary_key_column ] ][] = array(
					&#039;column&#039;         =&gt; $meta_key,
					&#039;original_value&#039; =&gt; $row[ $meta_alias ],
					&#039;new_value&#039;      =&gt; $row[ $destination_alias ],
				);
			}
		}

		return $failed_ids;
	}

	/**
	 * Helper method to pre-process rows to make sure we parse the correct type.
	 *
	 * @param array  $row Both migrated and source data for a single row.
	 * @param array  $schema Column schema.
	 * @param string $alias Name of source column.
	 * @param string $destination_alias Name of destination column.
	 *
	 * @return array Processed row.
	 */
	private function pre_process_row( $row, $schema, $alias, $destination_alias ) {
		if ( ! isset( $row[ $alias ] ) ) {
			$row[ $alias ] = $this-&gt;get_type_defaults( $schema[&#039;type&#039;] );
		}
		if ( is_null( $row[ $destination_alias ] ) ) {
			$row[ $destination_alias ] = $this-&gt;get_type_defaults( $schema[&#039;type&#039;] );
		}
		if ( in_array( $schema[&#039;type&#039;], array( &#039;int&#039;, &#039;decimal&#039;, &#039;float&#039; ), true ) ) {
			if ( &#039;&#039; === $row[ $alias ] || null === $row[ $alias ] ) {
				$row[ $alias ] = 0; // $wpdb-&gt;prepare forces empty values to 0.
			}
			$row[ $alias ]             = wc_format_decimal( floatval( $row[ $alias ] ), false, true );
			$row[ $destination_alias ] = wc_format_decimal( floatval( $row[ $destination_alias ] ), false, true );
		}
		if ( &#039;bool&#039; === $schema[&#039;type&#039;] ) {
			$row[ $alias ]             = wc_string_to_bool( $row[ $alias ] );
			$row[ $destination_alias ] = wc_string_to_bool( $row[ $destination_alias ] );
		}
		if ( &#039;date_epoch&#039; === $schema[&#039;type&#039;] ) {
			if ( &#039;&#039; === $row[ $alias ] || null === $row[ $alias ] ) {
				$row[ $alias ] = null;
			} else {
				$row[ $alias ] = ( new \DateTime( &quot;@{$row[ $alias ]}&quot; ) )-&gt;format( &#039;Y-m-d H:i:s&#039; );
			}
			if ( &#039;0000-00-00 00:00:00&#039; === $row[ $destination_alias ] ) {
				$row[ $destination_alias ] = null;
			}
		}
		return $row;
	}

	/**
	 * Helper method to get default value of a type.
	 *
	 * @param string $type Type.
	 *
	 * @return mixed Default value.
	 */
	private function get_type_defaults( $type ) {
		switch ( $type ) {
			case &#039;float&#039;:
			case &#039;int&#039;:
			case &#039;decimal&#039;:
				return 0;
			case &#039;string&#039;:
				return &#039;&#039;;
		}
	}
}
</code></pre>
            </article>
            </div>
        </div>
        <a href="#top" class="phpdocumentor-back-to-top"><i class="fas fa-chevron-circle-up"></i></a>

    </main>

    <footer class="phpdocumentor phpdocumentor-footer">
    <div class="phpdocumentor-section">
        <span>WooCommerce Code Reference API documentation generated by <a href="http://www.phpdoc.org/">phpDocumentor</a> on August 24th, 2023 at 08:49 am.</span>
    </div>
</footer>

    <script>
        cssVars({});
    </script>
    <script>
        var searchParams = {
            'searchIndex': '..\/js\/searchIndex.json'
        };
    </script>
    <script src="../js/searchIndex.js?updated=1692866952"></script>
    <script src="../js/search.js?updated=1692866952"></script>
</body>
</html>
